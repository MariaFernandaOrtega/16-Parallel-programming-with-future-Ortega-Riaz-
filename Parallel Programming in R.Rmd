---
title: "Parallel Programming in R"
output: html_document
date: "2022-11-01"
By Danial Riaz and Fernanda Candido Gomes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load necessary libraries

```{r}
library(tidyverse)
library(tictoc)
library(parallel)
library(future.apply)
library(furrr)      
plan(multisession)# telling R that we want to implement the iteration in parallel
```

## Assess your own computer speed

Our abilty to go parallel hinges on the number of CPU cores available to us. The simplest way to obtain this information from R is with the detectCores() function:

```{r}
detectCores()
```
This will indicate the number of CPU cores you have available on your computer to utilize and therefore how 'fast' your system can operate. You can adjust your expectations accordingly. 

## Assessing time saved through parallel programming

Lets assess the potential time saved through parallel programming by creating a test function called standard_function() 

```{r}
standard_function = 
  function(x = 1) {
    x_sq = x^2 
    d = tibble(value = x, value_squared = x_sq)
    Sys.sleep(2)
    return(d)
  }

```

Let’s iterate over this function using the standard lapply() method that we’re already familiar with by now. Note that this iteration will be executed in serial. We’ll use the tictoc package to record timing.


```{r}
tic()
serial_func = lapply(1:12, standard_function) %>% bind_rows()
toc()
```
As expected, the iteration took about 24 seconds to run because of the enforced break after every sequential iteration (i.e. Sys.sleep(2)). On the other hand, this means that we can easily speed things up by iterating in parallel.

## Parallel Programming with 'lapply'

Now lets implement the parallel iteration using the future.apply package. Note that the parameters of the problem are otherwise unchanged.

```{r}
tic()
future_func = future_lapply(1:12, standard_function) %>% bind_rows() #slightly amend the previous lapply() function
toc(log = TRUE)
```

We see that only with a minor modification of our syntax and using the plan(multisession) command we have reduced the time taken by R to only a quarter of the original time. 


## Parallel Programming with 'purrr'

If you prefer the purrr::map() family of functions for iteration and are feeling left out; don’t worry. The furrr package has you covered. Once again, the syntax for these parallel functions will be very little changed from their serial versions. We simply have to tell R that we want to run things in parallel with plan(multisession) and then slightly amend our map call to future_map_dfr().


```{r}
tic()
furrr_func = future_map_dfr(1:12, standard_function)
toc()
```








